/*
  admin_withdrawal_updates.js
  ---------------------------
  Drop-in helper module for your existing index.html scripts.
  Purpose:
    - Add unified Withdrawal History feature (Dividend / Capital / Affiliate)
    - Enforce 720-day holding period for capital withdrawals (lockup)
    - Show countdown timers in My Portfolio & Admin > Investment
    - Track days count-up since approval for each investment (Admin view)
    - Keep Withdrawal history per-investment and global WithdrawalHistory collection
    - Treat affiliate withdrawals as expense in Financials calculation
    - Ensure approved capital withdrawals DO NOT auto-revoke investments (manual revoke)

  How to use:
    1. Save this file and include it after your firebase init code in index.html:
       <script src="/path/to/admin_withdrawal_updates.js"></script>
    2. Make sure the following Firestore collections exist or will be used:
       - investments (existing)
       - dividendWithdrawals (existing)
       - capitalWithdrawals (existing)
       - affiliateWithdrawals (existing)
       - withdrawalHistory (NEW global log, optional)
    3. Add data- attributes to portfolio and admin DOM elements so the helper can attach timers:
       - For portfolio list items: class="portfolio-item" data-investment-id="INVESTMENT_ID"
         also include element for countdown: <div class="portfolio-countdown" data-investment-id="INVESTMENT_ID"></div>
       - For admin investments list: class="admin-investment-item" data-investment-id="INVESTMENT_ID"
         include <div class="admin-days-since" data-investment-id="INVESTMENT_ID"></div>
         include <div class="admin-investment-history" data-investment-id="INVESTMENT_ID"></div>
    4. Call `initWithdrawalFeature()` once after Firebase is ready and DOM has loaded.

  Notes on behavior choices I made (explainable & tweakable):
    - Holding period is 720 days. The UI will disable "Request Capital Withdrawal" if holding days < 720.
    - If holdingDays < 360, the button area will show text: "360 days holding period" as requested.
      (If you'd rather always show remaining days, tweak the text logic inside formatHoldingMessage())
    - When a withdrawal is approved (admin action), the capital withdrawal request document will be updated to status: 'approved', and a history entry will be appended to both the investment document and the new global `withdrawalHistory` collection.
    - Importantly: approving capital withdrawal does NOT revoke/remove the investment. Admin must manually revoke in the investments panel.

*/

// Wrap in an IIFE to avoid leaking globals
(function(){
  // Ensure firebase & db are available
  if (typeof firebase === 'undefined' || !firebase.firestore) {
    console.warn('Firebase not found. Include admin_withdrawal_updates.js after Firebase init.');
    return;
  }

  const db = firebase.firestore();

  // constants
  const CAPITAL_HOLDING_DAYS = 720; // lockup period
  const HOLDING_WARNING_DAYS = 360; // show specific message when under this threshold

  // Helper: calculate days difference between two Date objects
  function daysBetween(dateA, dateB) {
    const msPerDay = 24 * 60 * 60 * 1000;
    return Math.floor((dateA.getTime() - dateB.getTime()) / msPerDay);
  }

  // Helper: format a countdown (days, hrs, mins)
  function formatCountdown(msRemaining) {
    if (msRemaining <= 0) return '0d 0h 0m';
    const minutes = Math.floor(msRemaining / (60*1000)) % 60;
    const hours = Math.floor(msRemaining / (60*60*1000)) % 24;
    const days = Math.floor(msRemaining / (24*60*60*1000));
    return `${days}d ${hours}h ${minutes}m`;
  }

  // Compose holding message shown on locked capital withdraw button area
  function formatHoldingMessage(holdingDays, remainingDays) {
    if (holdingDays < HOLDING_WARNING_DAYS) {
      return '360 days holding period'; // user requested exact message when locked
    }
    return `Locked. ${remainingDays} day(s) remaining until eligible`;
  }

  // Append history entry to investment doc and write global withdrawalHistory log
  async function appendInvestmentHistory(investmentId, historyEntry) {
    if (!investmentId) return;

    const invRef = db.collection('investments').doc(investmentId);
    const globalRef = db.collection('withdrawalHistory').doc();

    try {
      // Append into investment.history array field using arrayUnion
      await invRef.set({ history: firebase.firestore.FieldValue.arrayUnion(historyEntry) }, { merge: true });

      // Also write a separate global log for auditing/reporting
      await globalRef.set({
        investmentId,
        timestamp: firebase.firestore.Timestamp.now(),
        ...historyEntry
      });

      console.log('✅ History appended for', investmentId, historyEntry);
      return true;
    } catch (err) {
      console.error('❌ Failed to append history', err);
      return false;
    }
  }

  // Approve a capital withdrawal request (admin action)
  // IMPORTANT: does NOT revoke the investment. Admin must revoke manually in investments panel.
  async function approveCapitalWithdrawal(requestId) {
    try {
      const reqRef = db.collection('capitalWithdrawals').doc(requestId);
      const reqSnap = await reqRef.get();
      if (!reqSnap.exists) throw new Error('Request not found');
      const req = reqSnap.data();

      if (req.status === 'approved') {
        console.log('Request already approved');
        return;
      }

      // Update request status
      await reqRef.set({ status: 'approved', approvedAt: firebase.firestore.Timestamp.now() }, { merge: true });

      // Add history entry to investment if linked
      if (req.investmentId) {
        const historyEntry = {
          type: 'capital_withdrawal',
          amount: req.amount || 0,
          requestId,
          note: `Capital withdrawal approved by admin (manual revoke required)`,
          date: firebase.firestore.Timestamp.now()
        };
        await appendInvestmentHistory(req.investmentId, historyEntry);
      }

      // Add global withdrawalHistory entry
      await db.collection('withdrawalHistory').add({
        category: 'capital',
        requestId,
        investmentId: req.investmentId || null,
        amount: req.amount || 0,
        status: 'approved',
        approvedAt: firebase.firestore.Timestamp.now()
      });

      console.log('✅ Capital withdrawal approved (manual revoke required).');
      return true;
    } catch (err) {
      console.error('❌ approveCapitalWithdrawal failed', err);
      return false;
    }
  }

  // Approve a dividend withdrawal request
  async function approveDividendWithdrawal(requestId) {
    try {
      const reqRef = db.collection('dividendWithdrawals').doc(requestId);
      const reqSnap = await reqRef.get();
      if (!reqSnap.exists) throw new Error('Request not found');
      const req = reqSnap.data();

      if (req.status === 'approved') return;

      await reqRef.set({ status: 'approved', approvedAt: firebase.firestore.Timestamp.now() }, { merge: true });

      if (req.investmentId) {
        const historyEntry = {
          type: 'dividend_withdrawal',
          amount: req.amount || 0,
          requestId,
          date: firebase.firestore.Timestamp.now()
        };
        await appendInvestmentHistory(req.investmentId, historyEntry);
      }

      await db.collection('withdrawalHistory').add({
        category: 'dividend', requestId, investmentId: req.investmentId || null, amount: req.amount || 0, status: 'approved', approvedAt: firebase.firestore.Timestamp.now()
      });

      console.log('✅ Dividend withdrawal approved and history appended');
      return true;
    } catch (err) {
      console.error('❌ approveDividendWithdrawal failed', err);
      return false;
    }
  }

  // Approve an affiliate withdrawal request (admin action) - considered an expense
  async function approveAffiliateWithdrawal(requestId) {
    try {
      const reqRef = db.collection('affiliateWithdrawals').doc(requestId);
      const reqSnap = await reqRef.get();
      if (!reqSnap.exists) throw new Error('Request not found');
      const req = reqSnap.data();

      if (req.status === 'approved') return;

      await reqRef.set({ status: 'approved', approvedAt: firebase.firestore.Timestamp.now() }, { merge: true });

      // Add to global withdrawalHistory (category affiliate)
      await db.collection('withdrawalHistory').add({
        category: 'affiliate', requestId, affiliateId: req.affiliateId || null, amount: req.amount || 0, status: 'approved', approvedAt: firebase.firestore.Timestamp.now()
      });

      // Also append to a financials/expenses collection so Financial Statement can consume it
      await db.collection('financials').doc('expenses').set({
        affiliateWithdrawalsTotal: firebase.firestore.FieldValue.increment(req.amount || 0)
      }, { merge: true });

      console.log('✅ Affiliate withdrawal approved and recorded as expense');
      return true;
    } catch (err) {
      console.error('❌ approveAffiliateWithdrawal failed', err);
      return false;
    }
  }

  // Check if a given investment is eligible for capital withdrawal
  // Returns { eligible: bool, holdingDays: number, remainingDays: number }
  function checkCapitalEligibility(investment) {
    // Investment should have approvedAt timestamp
    const approvedAt = investment && (investment.approvedAt ? (investment.approvedAt.toDate ? investment.approvedAt.toDate() : new Date(investment.approvedAt)) : null);
    if (!approvedAt) return { eligible: false, holdingDays: 0, remainingDays: CAPITAL_HOLDING_DAYS };

    const now = new Date();
    const holdingDays = daysBetween(now, approvedAt);
    const remainingDays = Math.max(0, CAPITAL_HOLDING_DAYS - holdingDays);
    const eligible = holdingDays >= CAPITAL_HOLDING_DAYS;
    return { eligible, holdingDays, remainingDays };
  }

  // UI: attach countdowns to all portfolio items and admin items
  function attachCountdowns() {
    // Portfolio countdowns
    const portfolioElems = document.querySelectorAll('.portfolio-countdown[data-investment-id]');
    portfolioElems.forEach(el => {
      const id = el.getAttribute('data-investment-id');
      if (!id) return;

      // poll investment doc once and keep interval
      db.collection('investments').doc(id).onSnapshot(doc => {
        const inv = doc.exists ? doc.data() : null;
        if (!inv) return;

        const approvedAt = inv.approvedAt ? (inv.approvedAt.toDate ? inv.approvedAt.toDate() : new Date(inv.approvedAt)) : null;
        if (!approvedAt) {
          el.textContent = 'Not approved yet';
          return;
        }

        // Setup interval to update every minute
        if (el._interval) clearInterval(el._interval);
        function update() {
          const now = new Date();
          const msSinceApproval = now - approvedAt;
          const holdingDays = Math.floor(msSinceApproval / (24*60*60*1000));
          const remainingMs = Math.max(0, (CAPITAL_HOLDING_DAYS*24*60*60*1000) - msSinceApproval);
          const remainingDays = Math.ceil(remainingMs / (24*60*60*1000));

          const eligibility = checkCapitalEligibility(inv);

          if (eligibility.eligible) {
            el.textContent = `Eligible for capital withdrawal`;
          } else {
            // if under warning threshold, show special message
            if (eligibility.holdingDays < HOLDING_WARNING_DAYS) {
              el.textContent = formatHoldingMessage(eligibility.holdingDays, eligibility.remainingDays);
            } else {
              el.textContent = `Locked — ${remainingDays} day(s) remaining (${formatCountdown(remainingMs)})`;
            }
          }
        }
        update();
        el._interval = setInterval(update, 60*1000); // update every minute
      });
    });

    // Admin days-since (count-up)
    const adminElems = document.querySelectorAll('.admin-days-since[data-investment-id]');
    adminElems.forEach(el => {
      const id = el.getAttribute('data-investment-id');
      if (!id) return;
      db.collection('investments').doc(id).onSnapshot(doc => {
        const inv = doc.exists ? doc.data() : null;
        if (!inv || !inv.approvedAt) {
          el.textContent = 'Not approved';
          return;
        }
        const approvedAt = inv.approvedAt.toDate ? inv.approvedAt.toDate() : new Date(inv.approvedAt);
        // update every minute
        if (el._interval) clearInterval(el._interval);
        function updateCountUp() {
          const now = new Date();
          const ms = now - approvedAt;
          const days = Math.floor(ms / (24*60*60*1000));
          const hours = Math.floor(ms / (60*60*1000)) % 24;
          const mins = Math.floor(ms / (60*1000)) % 60;
          el.textContent = `${days}d ${hours}h ${mins}m since approved`;
        }
        updateCountUp();
        el._interval = setInterval(updateCountUp, 60*1000);
      });
    });

    // Admin investment history rendering
    const historyElems = document.querySelectorAll('.admin-investment-history[data-investment-id]');
    historyElems.forEach(el => {
      const id = el.getAttribute('data-investment-id');
      if (!id) return;
      db.collection('investments').doc(id).onSnapshot(doc => {
        const inv = doc.exists ? doc.data() : null;
        if (!inv) { el.innerHTML = '<em>No investment data</em>'; return; }
        const history = inv.history || [];
        if (!history.length) { el.innerHTML = '<em>No history yet</em>'; return; }
        // Sort reverse chronological
        const sorted = history.slice().sort((a,b)=>{
          const ta = a.date ? (a.date.toDate ? a.date.toDate().getTime() : new Date(a.date).getTime()) : 0;
          const tb = b.date ? (b.date.toDate ? b.date.toDate().getTime() : new Date(b.date).getTime()) : 0;
          return tb - ta;
        });
        el.innerHTML = '<ul class="text-sm space-y-1">' + sorted.map(h=>{
          const d = h.date ? (h.date.toDate ? h.date.toDate().toLocaleString() : new Date(h.date).toLocaleString()) : new Date().toLocaleString();
          return `<li>• <strong>${h.type.replace(/_/g,' ')}</strong> — ${h.amount ? '₱'+h.amount : ''} <span class="opacity-70">${d}</span> ${h.note?'- '+h.note:''}</li>`;
        }).join('') + '</ul>';
      });
    });
  }

  // Hook: prevent capital withdrawal request creation if not eligible (client-side check)
  // To use: call this when user clicks "Request Capital Withdrawal" and pass investmentId
  async function tryCreateCapitalWithdrawalRequest(investmentId, requestPayload) {
    try {
      const invRef = db.collection('investments').doc(investmentId);
      const invSnap = await invRef.get();
      if (!invSnap.exists) throw new Error('Investment not found');
      const inv = invSnap.data();
      const eligibility = checkCapitalEligibility(inv);
      if (!eligibility.eligible) {
        // Return a structured error telling UI what message to show
        return { success: false, reason: 'not_eligible', message: formatHoldingMessage(eligibility.holdingDays, eligibility.remainingDays), holdingDays: eligibility.holdingDays, remainingDays: eligibility.remainingDays };
      }

      // create request in collection
      const reqRef = db.collection('capitalWithdrawals').doc();
      const payload = {
        investmentId,
        status: 'pending',
        createdAt: firebase.firestore.Timestamp.now(),
        ...requestPayload
      };
      await reqRef.set(payload);

      // Add global history entry signifying request creation
      await db.collection('withdrawalHistory').add({
        category: 'capital', requestId: reqRef.id, investmentId, amount: requestPayload.amount || 0, status: 'pending', createdAt: firebase.firestore.Timestamp.now()
      });

      console.log('✅ Capital withdrawal request created', reqRef.id);
      return { success: true, id: reqRef.id };
    } catch (err) {
      console.error('❌ tryCreateCapitalWithdrawalRequest failed', err);
      return { success: false, reason: 'error', message: err.message };
    }
  }

  // Financial Statement helper: include affiliate withdrawals as expense when computing totals
  // Example usage: const financials = await computeFinancialStatement();
  async function computeFinancialStatement() {
    // This is a simple example. Tweak per your financial schema.
    const totals = { affiliateWithdrawals: 0, otherExpenses: 0, totalExpenses: 0, totalIncome: 0 };

    try {
      // Sum affiliateWithdrawalsTotal from financials.expenses doc if present
      const expensesDoc = await db.collection('financials').doc('expenses').get();
      if (expensesDoc.exists) {
        const data = expensesDoc.data();
        totals.affiliateWithdrawals = data.affiliateWithdrawalsTotal || 0;
        totals.otherExpenses = data.otherExpensesTotal || 0;
      }

      // compute other totals (example: sum of all investments, dividends etc.)
      // You can expand this to read specific collections or use aggregate queries via Cloud Functions

      totals.totalExpenses = (totals.affiliateWithdrawals || 0) + (totals.otherExpenses || 0);
      // totalIncome remains to be implemented based on your revenue collections
      return totals;
    } catch (err) {
      console.error('❌ computeFinancialStatement failed', err);
      return totals;
    }
  }

  // Initialization: attach countdowns when DOM ready
  function initWithdrawalFeature() {
    document.addEventListener('DOMContentLoaded', () => {
      attachCountdowns();
      console.log('Withdrawal feature initialized');
    });
  }

  // Expose functions for admin UI to call (e.g. wire buttons to these handlers)
  window.adminWithdrawalHelpers = {
    initWithdrawalFeature,
    approveCapitalWithdrawal,
    approveDividendWithdrawal,
    approveAffiliateWithdrawal,
    tryCreateCapitalWithdrawalRequest,
    checkCapitalEligibility,
    computeFinancialStatement,
    appendInvestmentHistory
  };

})();
